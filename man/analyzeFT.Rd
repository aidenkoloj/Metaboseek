% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/methods_analyzeFT.R
\name{analyzeFT}
\alias{analyzeFT}
\alias{removeNAs,MseekFT-method}
\alias{removeNAs}
\alias{FTNormalize,MseekFT-method}
\alias{FTNormalize}
\alias{FTBasicAnalysis,MseekFT-method}
\alias{FTBasicAnalysis}
\alias{getMseekIntensities,MseekFT,listOrNULL,missing-method}
\alias{getMseekIntensities}
\alias{getMseekIntensities,MseekFT,listOrNULL,MseekFTOrNULL-method}
\alias{FTOldPeakShapes,MseekFT,listOrNULL-method}
\alias{FTOldPeakShapes}
\alias{FTPeakShapes,MseekFT,listOrNULL-method}
\alias{FTPeakShapes}
\alias{FTMzMatch,MseekFT-method}
\alias{FTMzMatch}
\alias{FTT.test,MseekFT-method}
\alias{FTT.test}
\alias{FTAnova,MseekFT-method}
\alias{FTAnova}
\alias{FTCluster,MseekFT-method}
\alias{FTCluster}
\alias{FTPCA,MseekFT-method}
\alias{FTPCA}
\alias{FTMS2scans,MseekFT,listOrNULL-method}
\alias{FTMS2scans}
\alias{getSpecList,MseekFT,listOrNULL-method}
\alias{FTedges,MseekFT-method}
\alias{matchReference,MseekFT,MseekFT-method}
\alias{matchReference,MseekGraph,MseekFT-method}
\alias{LabelFinder,MseekFamily-method}
\alias{LabelFinder}
\alias{PatternFinder,MseekFamily-method}
\alias{PatternFinder}
\title{analyzeFT}
\usage{
\S4method{analyzeFT}{MseekFT,listOrNULL,FTAnalysisParam}(object, MSData, param)

\S4method{removeNAs}{MseekFT}(object, intensityCols = NULL, replacement = 0)

\S4method{FTNormalize}{MseekFT}(
  object,
  normalize = TRUE,
  intensityCols = NULL,
  logNormalized = FALSE,
  zeroReplacement = NULL
)

\S4method{FTBasicAnalysis}{MseekFT}(
  object,
  intensityCols = NULL,
  grouping = NULL,
  controlGroup = NULL
)

\S4method{getMseekIntensities}{MseekFT,listOrNULL,missing}(
  object,
  rawdata,
  adjustedRT = TRUE,
  ppm = 5,
  rtrange = TRUE,
  rtw = 5,
  areaMode = FALSE,
  BPPARAM = SerialParam(),
  baselineSubtract = TRUE,
  SN = NULL,
  columnSuffix = "__XIC"
)

\S4method{getMseekIntensities}{MseekFT,listOrNULL,MseekFTOrNULL}(
  object,
  rawdata,
  importFrom,
  adjustedRT = TRUE,
  ppm = 5,
  rtrange = TRUE,
  rtw = 5,
  areaMode = FALSE,
  BPPARAM = SerialParam(),
  baselineSubtract = TRUE,
  SN = NULL,
  columnSuffix = "__XIC"
)

\S4method{FTOldPeakShapes}{MseekFT,listOrNULL}(object, rawdata, ppm = 5, workers = 1)

\S4method{FTPeakShapes}{MseekFT,listOrNULL}(object, rawdata, ppm = 5, workers = 1)

\S4method{FTMzMatch}{MseekFT}(object, db, ppm = 5, mzdiff = 0.001)

\S4method{FTT.test}{MseekFT}(
  object,
  intensityCols = NULL,
  grouping = NULL,
  adjmethod = "bonferroni"
)

\S4method{FTAnova}{MseekFT}(object, intensityCols = NULL, grouping = NULL)

\S4method{FTCluster}{MseekFT}(object, intensityCols = NULL, numClusters = 100L)

\S4method{FTPCA}{MseekFT}(object, intensityCols = NULL, featureMode = FALSE)

\S4method{FTMS2scans}{MseekFT,listOrNULL}(object, rawdata, ppm = 5, rtw = 10, uniqueMatch = FALSE)

\S4method{getSpecList}{MseekFT,listOrNULL}(
  object,
  rawdata,
  merge = TRUE,
  noiselevel = 0,
  ppm = 5,
  mzdiff = 0.0005,
  mzThreshold = NULL
)

\S4method{FTedges}{MseekFT}(object, useParentMZs = TRUE, minpeaks = 6, mzdiff = 0.0005)

\S4method{matchReference}{MseekFT,MseekFT}(
  object,
  query,
  parent_mztol = 0.001,
  parent_ppm = 5,
  rttol = 5,
  getCosine = TRUE,
  cosineThreshold = NULL,
  singleHits = TRUE,
  queryPrefix = "query__",
  returnMapping = FALSE,
  ...
)

\S4method{matchReference}{MseekGraph,MseekFT}(
  object,
  query,
  parent_mztol = 0.001,
  parent_ppm = 5,
  rttol = 5,
  getCosine = TRUE,
  cosineThreshold = NULL,
  singleHits = TRUE,
  queryPrefix = "query__",
  returnMapping = FALSE,
  ...
)

\S4method{LabelFinder}{MseekFamily}(object, object2, MSData, newName, ...)

\S4method{PatternFinder}{MseekFamily}(
  object,
  MSData,
  peaks,
  losses,
  ppm = 5,
  mzdiff = 0.002,
  noise = 0.02
)
}
\arguments{
\item{object}{an MseekFT or data.frame object.}

\item{MSData, rawdata}{list of xcmsRaw objects}

\item{param}{a \code{\link{FTAnalysisParam}} object}

\item{intensityCols}{a vector of column names which contain intensity values 
to use for a calculation step. If not defined, will use the columns defined 
in the object as \code{$intensities}.}

\item{replacement}{value to put in place of NA values}

\item{logNormalized}{if TRUE, applies log10 to intensity values after normalization}

\item{grouping}{named list of character vectors, defining column 
names for different sample groups.}

\item{controlGroup}{character() defining which sample group serves as control
(will calculate foldChanges over control if not NULL)}

\item{adjustedRT}{use adjusted RTs for all samples for which it is available}

\item{ppm}{ppm mz tolerance}

\item{rtrange}{if TRUE, will use \code{rtw} starting out from the \code{rtmin} 
and \code{rtmax} values instead of \code{rt}}

\item{rtw}{retention time window to get the intensity from, +/- in seconds}

\item{areaMode}{if TRUE, will calculate peak areas rather than mean intensities}

\item{BPPARAM}{Parallel processing settings, see 
\code{\link[BiocParallel]{BiocParallelParam-class}}and 
\code{\link[BiocParallel]{bpparam}}}

\item{baselineSubtract}{subtract baseline when calculating intensities}

\item{SN}{signal to noise ratio. If not NULL, all peaks with max/min peak intensity below this will be reported as intensity 0. Requires Baselinesubstraction to be off.}

\item{importFrom}{a \code{MseekFT} object to use as source for Mseek intensities.}

\item{workers}{number of worker processes}

\item{db}{data base to search, either a vector of file paths .csv files
or a data.frame, see \code{\link{mzMatch}()}}

\item{mzdiff}{mz tolerance in fragment ion matching}

\item{adjmethod}{method to use for p-value adjustment, see \code{\link[stats]{p.adjust}()}}

\item{numClusters}{number of clusters to group the features in. Will 
automatically be set to be at most number of features - 1.}

\item{featureMode}{if TRUE, will cluster molecular features by intensities 
across samples. If FALSE, will cluster samples by intensities across features}

\item{uniqueMatch}{if TRUE, assign MS2 scans only to the matching feature with the closest rt}

\item{merge}{if TRUE, will merge spectra for each molecular feature}

\item{mzThreshold}{if not NULL, will remove all peaks with an mz below this value from the spectra.}

\item{useParentMZs}{if TRUE, will also match neutral losses between spectra}

\item{minpeaks}{minimum number of peaks that have to match between two spectr
to allow calculation of a score}

\item{query}{an object that contains molecular features that will be matched to
\code{object}, by a customizable combination of retention time, m/z and MS2 similarity matching}

\item{parent_mztol}{parent m/z matching tolerance (absolute); matches have to differ 
by less than either \code{parent_mztol} or \code{parent_ppm}. If NULL, will ignore m/z for matching.}

\item{parent_ppm}{parent m/z matching tolerance in ppm; matches have to differ 
by less than either \code{parent_mztol} or \code{parent_ppm}.}

\item{rttol}{retention time tolerance in seconds. If NULL, will ignore rt for matching}

\item{getCosine}{if TRUE, will calculate MS2 scan similarity for features that
match by rt and m/z (or between all features if rttol and parent_mztol are not set)}

\item{cosineThreshold}{minimum cosine value between features for them to be considered matches.
will not filter for MS2 similarity score if NULL.}

\item{singleHits}{allow only one query hit for each reference molecular feature 
(will pick the one with best MS2 similarity)}

\item{queryPrefix}{prefix for columns transferred from the matched query object}

\item{returnMapping}{if true, returns a matrix defining the indices of matched features between object and query}

\item{...}{additional arguments passed to internal methods (e. g. \code{\link[MassTools]{network1}()})}

\item{newName}{name for the LabelFinder result object}

\item{peaks}{names list of mz values (like output from \code{parsePatterns()}) to look for in spectra}

\item{losses}{names list of mz values (like output from \code{parsePatterns()}) to look for in spectra (as neutral losses)}

\item{noise}{remove peaks below this relative intensity when merging spectra (relative to highest peak, not percent)}
}
\value{
an object of the same class as \code{object}, with analyses performed 
and recorded in the \code{processHistory}
}
\description{
\code{analyzeFT()}: wrapper function for the methods described here. 
Analyze MseekFT objects, recording a processing history .
 Will use intensity columns and grouping information from the MseekFT object
 if available. See \code{\link{analyzeTable}} for the old version of this.

\code{removeNAs}: remove NA values from a range of columns and replace them with another value

\code{FTNormalize}: Replaces zeroes by the globally smallest 
non-zero intensity value, then normalizes a feature table such that the mean
 values of all intensity columns will be equal. See also 
 \code{\link{featureTableNormalize}()}

\code{FTBasicAnalysis}: calculate fold changes between groups of samples. See also 
\code{\link{foldChange}()} and \code{\link{featureCalcs}()}for a description of the resulting columns

\code{getMseekIntensities}: get EIC-based intensities for each
 molecular feature in the MseekFT object for each file in \code{rawdata}.
 if another MseekFT object is supplied as \code{importFrom}, will try to transfer MseekIntensities from there if 
 all settings, features and MS data files are equivalent. See also \code{\link{exIntensities}}

\code{FTOldPeakShapes}: calculate score for peak shapes. This method is kept
 for backwards reproducibility and not recommended, because \code{FTPeakShapes()}
is much faster. See also \code{\link{bestgauss}()}

\code{FTPeakShapes}: calculate score for peak shapes. Adds a 
\code{Fast_Peak_Quality} column to the data.frame in the MseekFT object. See 
also \code{\link{fastPeakShapes}()}

\code{FTMzMatch}: Match mz values in this MseekFT with mz values from a data base. 
See also \code{\link{mzMatch}()}

\code{FTT.test}: calculate t-test between samples. Works only if there are 
two groups in \code{grouping} with multiple members. See also \code{\link{multittest}()}

\code{FTAnova}: calculate two-way ANOVA between multiple sample groups.
 See also \code{\link{MseekAnova}()}

\code{FTCluster}: cluster the feature table with cluster::clara()
 See also \code{\link{MosCluster}()}

\code{FTPCA}: Calculate Principal Component Analysis to cluster either features or samples

\code{FTMS2scans}: find MS2 scans across files and save their file and scan numbers in
 the MseekFT object as a text column.

\code{getSpecList}: generate a list of MS2 spectra inside the object
from MS2 spectra that were identified with the \code{FTMS2scans()} method.

\code{FTedges}: wrapper for the 
\code{MassTools::\link[MassTools]{makeEdges}()} function, matching a list of 
MS2 spectra available inside the object and generating similarity scores.

\code{matchReference}: Match molecular features between a 
\code{MseekGraph} or \code{MseekFT} object and another \code{MseekFT} object
 by a customizable combination of retention time, m/z and MS2 similarity
  matching

\code{LabelFinder}: Find labeled features, see \code{\link{findLabels}()}

\code{PatternFinder}: Find Pattern in Spectra
}
\examples{
MseekExamplePreload(data = T, tables = T)
LabelFinderResults <- LabelFinder(object = tab2, #remove intensity columns to have them replaced with new ones from rawdata
                                object2 = tab2,
                                newName = "Test",
                                MSData = MSD$data,
                                ref_intensityCols = tab2$intensities[1:3],
                                comp_intensityCols = tab2$intensities[4:7],
                                labelmz = 2*1.00335,
                                ifoldS1 = 10,
                                ifoldS2 = 10000)

MseekExamplePreload(data = T, tables = T)
tab1 <- FTMS2scans(tab1, MSD$data)
LabelFinderResults <- PatternFinder(object = tab1, #needs to have an MS2
                                MSData = MSD$data,
                                peaks = list(testpeak = 85.02895),
                                losses = list(testloss = 18.010788))
LabelFinderResults$df$matched_losses
LabelFinderResults$df$matched_patterns

}
